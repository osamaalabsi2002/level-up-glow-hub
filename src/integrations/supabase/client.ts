
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from "sonner";

const SUPABASE_URL = "https://wbsftjsuvzleompqfass.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indic2Z0anN1dnpsZW9tcHFmYXNzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY1MjUxODUsImV4cCI6MjA2MjEwMTE4NX0.VnX4Yc3BHFNEzZHcuPD8aVDqcZ0bNHpwhQo2W7ngXJQ";

// Maximum number of retries for failed requests
const MAX_RETRIES = 3;
// Base time in ms between retries (will be multiplied by attempt number)
const RETRY_DELAY_BASE = 1000;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create and configure the Supabase client
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
  global: {
    // Add request hooks to handle connection errors globally
    fetch: (url, options: RequestInit = {}) => {
      const controller = new AbortController();
      
      // Set a timeout to abort long-running requests
      const timeoutId = setTimeout(() => {
        controller.abort();
      }, 12000); // 12-second timeout
      
      let retryCount = 0;
      
      const makeRequest = async (): Promise<Response> => {
        try {
          // Ensure headers object exists
          options.headers = options.headers || {};
          
          // Create a new Headers object with the original headers
          const headers = new Headers(options.headers as HeadersInit);
          
          // Explicitly set the apikey header for all requests
    headers.set('apikey', SUPABASE_PUBLISHABLE_KEY);

// Get the current session token directly from localStorage
const tokenKey = 'sb-wbsftjsuvzleompqfass-auth-token';
try {
  const sessionData = localStorage.getItem(tokenKey);
  if (sessionData) {
    const parsedSession = JSON.parse(sessionData);
    if (parsedSession?.access_token) {
      headers.set('Authorization', `Bearer ${parsedSession.access_token}`);
      console.log('Auth token retrieved and set');
    }
  }
} catch (error) {
  console.error('Error retrieving auth token:', error);
}

          headers.set('Cache-Control', 'no-cache');
          headers.set('Pragma', 'no-cache');
          
          console.log('Supabase request headers:', {
            url,
            apikey: headers.has('apikey'),
            auth: headers.has('Authorization')
          });
          
          // Use the updated headers in the request
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
            headers
          });
          
          clearTimeout(timeoutId);
          
          // If unauthorized and we have a session, add debug info
          if (response.status === 401) {
            const session = JSON.parse(localStorage.getItem('sb-wbsftjsuvzleompqfass-auth-token') || '{}');
            console.error('401 Unauthorized error with active session:', {
              url,
              hasSession: !!session?.access_token,
              sessionExpiry: session?.expires_at ? new Date(session.expires_at * 1000).toISOString() : 'none',
              now: new Date().toISOString()
            });
          }
          
          if (!response.ok && (response.status >= 500 || response.status === 429) && retryCount < MAX_RETRIES) {
            // Server error or rate limit - retry with exponential backoff
            retryCount++;
            const delay = RETRY_DELAY_BASE * retryCount;
            console.log(`Retrying request (${retryCount}/${MAX_RETRIES}) after ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            return makeRequest();
          }
          
          return response;
        } catch (error: unknown) {
          clearTimeout(timeoutId);

          if (typeof error === 'object' && error !== null && 'name' in error && (error as { name: string }).name === 'AbortError') {
            console.warn('Request timed out:', url);
            if (!window.localStorage.getItem('connection_error_shown')) {
              toast.error("Connection timeout. Check your internet connection.", {
                id: "connection-timeout", 
                duration: 5000
              });

              window.localStorage.setItem('connection_error_shown', 'true');

              setTimeout(() => {
                window.localStorage.removeItem('connection_error_shown');
              }, 30000); // Clear the flag after 30 seconds
            }
          } else if (retryCount < MAX_RETRIES && navigator.onLine) {
            // Retry on network errors if we're still online and haven't exceeded retry limit
            retryCount++;
            const delay = RETRY_DELAY_BASE * retryCount;
            console.log(`Retrying request after error (${retryCount}/${MAX_RETRIES}) after ${delay}ms...`, error);
            await new Promise(resolve => setTimeout(resolve, delay));
            return makeRequest();
          } else {
            // Show offline notice only once every 30 seconds
            if (!window.localStorage.getItem('offline_error_shown') && !navigator.onLine) {
              toast.error("You appear to be offline. Some features may not work.", {
                id: "offline-error",
                duration: 5000
              });
              window.localStorage.setItem('offline_error_shown', 'true');
              setTimeout(() => {
                window.localStorage.removeItem('offline_error_shown');
              }, 30000);
            }
          }

          throw error;
        }
      };
      
      return makeRequest();
    }
  }
});

// Helper function to test connection and set app-wide connection state
export const checkSupabaseConnection = async (): Promise<boolean> => {
  try {
    const startTime = Date.now();
    // Quick lightweight query to test connection
    const { data, error } = await supabase.from('services').select('count(*)', { count: 'exact', head: true }).limit(1);
    const responseTime = Date.now() - startTime;
    
    if (error) {
      console.error("Supabase connection test failed:", error);
      localStorage.setItem('app_connection_state', 'error');
      return false;
    }
    
    console.log(`Supabase connection test successful (${responseTime}ms)`);
    localStorage.setItem('app_connection_state', 'connected');
    return true;
  } catch (err) {
    console.error("Supabase connection test exception:", err);
    localStorage.setItem('app_connection_state', 'error');
    return false;
  }
};

// Add event listeners for online/offline status
if (typeof window !== 'undefined') {
  // Connection restored handler
  window.addEventListener('online', () => {
    // Verify connection is really back by testing Supabase connection
    checkSupabaseConnection().then(isConnected => {
      if (isConnected) {
        toast.success("Connection restored", { id: "connection-restored" });
        window.localStorage.removeItem('connection_error_shown');
        window.localStorage.removeItem('offline_error_shown');
      }
    });
  });
  
  // Connection lost handler
  window.addEventListener('offline', () => {
    toast.error("You are offline. Some features may not work.", { id: "connection-lost" });
    localStorage.setItem('app_connection_state', 'offline');
  });
}
